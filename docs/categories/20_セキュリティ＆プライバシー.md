# セキュリティ&プライバシーアプリ分析

**調査日**: 2025年12月25日
**対象**: 87件のセキュリティ・プライバシーアプリ

---

## 概要

セキュリティアプリは、パスワード管理、暗号化通信、VPN、2FA認証など多岐にわたる。オープンソースならではの透明性が特に重要な分野。

---

## トップアプリ

| スター | アプリ | カテゴリ | 説明 |
|--------|--------|----------|------|
| 12,352 | Organic Maps | プライバシーマップ | 広告なし、追跡なし |
| 10,062 | SimpleX Chat | 暗号化チャット | ユーザーIDなし |
| 9,133 | Keybase | 暗号化 | E2E暗号化プラットフォーム |
| 9,014 | Outline | VPN | セキュアVPN |
| 7,791 | Telegram | メッセージ | 高速・セキュア |
| 7,123 | Tutanota | メール | E2E暗号化メール |
| 6,782 | OnionShare | ファイル共有 | Tor匿名共有 |
| 6,537 | Mullvad VPN | VPN | プライバシー重視 |
| 6,178 | Standard Notes | メモ | 暗号化ノート |
| 4,500 | VPN On | VPN | 簡単VPN接続 |

---

## カテゴリ別詳細

### パスワード管理

| アプリ | スター | 特徴 |
|--------|--------|------|
| Padlock | 2,902 | ミニマリスト |
| Pass | 1,603 | Pass CLI連携 |
| Encryptr | 1,571 | ゼロ知識暗号化 |
| KeePassium | 1,484 | KeePass互換 |
| Strongbox | 1,408 | KeePass/Password Safe |
| MasterPassword | 1,139 | ステートレス |
| MiniKeePass | 890 | シンプルKeePass |

### VPN・ネットワーク

| アプリ | スター | プロトコル |
|--------|--------|-----------|
| Outline | 9,014 | Shadowsocks |
| Mullvad VPN | 6,537 | WireGuard/OpenVPN |
| VPN On | 4,500 | 複数対応 |
| WireGuard | 1,219 | WireGuard |
| Passepartout | 1,089 | OpenVPN |
| iCepa | 763 | Tor |
| Lockdown | 936 | ファイアウォール |

### 暗号化通信

| アプリ | スター | 機能 |
|--------|--------|------|
| SimpleX Chat | 10,062 | IDなし暗号化 |
| Telegram | 7,791 | MTProto |
| ChatSecure | 3,151 | OTR暗号化 |
| Mattermost | 2,535 | DevOps向け |
| FluffyChat | 2,125 | Matrix |
| Element | 1,806 | Matrix |

### 2FA・認証

| アプリ | スター | 対応 |
|--------|--------|------|
| Raivo OTP | 935 | TOTP/HOTP |
| Authenticator | 864 | シンプル2FA |
| FreeOTP | 733 | オープン標準 |

### 暗号化メール

| アプリ | スター | 特徴 |
|--------|--------|------|
| Tutanota | 7,123 | E2E暗号化 |
| ProtonMail | 1,546 | スイス拠点 |

---

## 技術パターン

### Keychain使用

```swift
import Security

class KeychainManager {
    enum KeychainError: Error {
        case duplicateItem
        case itemNotFound
        case unexpectedStatus(OSStatus)
    }

    func save(password: Data, for account: String, service: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: account,
            kSecAttrService as String: service,
            kSecValueData as String: password,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]

        let status = SecItemAdd(query as CFDictionary, nil)

        guard status == errSecSuccess else {
            if status == errSecDuplicateItem {
                throw KeychainError.duplicateItem
            }
            throw KeychainError.unexpectedStatus(status)
        }
    }

    func retrieve(account: String, service: String) throws -> Data {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: account,
            kSecAttrService as String: service,
            kSecReturnData as String: true
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess, let data = result as? Data else {
            throw KeychainError.itemNotFound
        }

        return data
    }

    func delete(account: String, service: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: account,
            kSecAttrService as String: service
        ]

        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.unexpectedStatus(status)
        }
    }
}
```

### 生体認証

```swift
import LocalAuthentication

class BiometricAuth {
    func authenticate(reason: String) async throws -> Bool {
        let context = LAContext()
        var error: NSError?

        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
            throw error ?? NSError(domain: "BiometricAuth", code: -1)
        }

        return try await context.evaluatePolicy(
            .deviceOwnerAuthenticationWithBiometrics,
            localizedReason: reason
        )
    }

    var biometricType: LABiometryType {
        let context = LAContext()
        _ = context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: nil)
        return context.biometryType
    }
}
```

### TOTP生成

```swift
import CryptoKit

struct TOTPGenerator {
    let secret: Data
    let digits: Int = 6
    let period: TimeInterval = 30

    func generate(at date: Date = Date()) -> String {
        let counter = UInt64(date.timeIntervalSince1970 / period)
        var counterBytes = counter.bigEndian

        let counterData = Data(bytes: &counterBytes, count: MemoryLayout<UInt64>.size)
        let key = SymmetricKey(data: secret)
        let hmac = HMAC<Insecure.SHA1>.authenticationCode(for: counterData, using: key)

        let hmacBytes = Array(hmac)
        let offset = Int(hmacBytes[hmacBytes.count - 1] & 0x0f)

        let truncatedHash =
            (UInt32(hmacBytes[offset]) & 0x7f) << 24 |
            (UInt32(hmacBytes[offset + 1]) & 0xff) << 16 |
            (UInt32(hmacBytes[offset + 2]) & 0xff) << 8 |
            (UInt32(hmacBytes[offset + 3]) & 0xff)

        let otp = truncatedHash % UInt32(pow(10, Double(digits)))
        return String(format: "%0\(digits)d", otp)
    }

    var remainingSeconds: Int {
        let elapsed = Date().timeIntervalSince1970.truncatingRemainder(dividingBy: period)
        return Int(period - elapsed)
    }
}
```

### E2E暗号化

```swift
import CryptoKit

class E2EEncryption {
    // 鍵ペア生成
    func generateKeyPair() -> (privateKey: Curve25519.KeyAgreement.PrivateKey, publicKey: Curve25519.KeyAgreement.PublicKey) {
        let privateKey = Curve25519.KeyAgreement.PrivateKey()
        return (privateKey, privateKey.publicKey)
    }

    // 共有シークレット生成
    func deriveSharedSecret(
        privateKey: Curve25519.KeyAgreement.PrivateKey,
        publicKey: Curve25519.KeyAgreement.PublicKey
    ) throws -> SymmetricKey {
        let sharedSecret = try privateKey.sharedSecretFromKeyAgreement(with: publicKey)
        return sharedSecret.hkdfDerivedSymmetricKey(
            using: SHA256.self,
            salt: Data(),
            sharedInfo: "E2E Encryption".data(using: .utf8)!,
            outputByteCount: 32
        )
    }

    // 暗号化
    func encrypt(message: Data, using key: SymmetricKey) throws -> Data {
        let sealedBox = try AES.GCM.seal(message, using: key)
        return sealedBox.combined!
    }

    // 復号
    func decrypt(ciphertext: Data, using key: SymmetricKey) throws -> Data {
        let sealedBox = try AES.GCM.SealedBox(combined: ciphertext)
        return try AES.GCM.open(sealedBox, using: key)
    }
}
```

---

## VPN実装

### WireGuard統合

```swift
import NetworkExtension
import WireGuardKit

class VPNManager: ObservableObject {
    @Published var status: NEVPNStatus = .disconnected

    private var manager: NETunnelProviderManager?

    func loadConfiguration() async throws {
        let managers = try await NETunnelProviderManager.loadAllFromPreferences()
        manager = managers.first ?? NETunnelProviderManager()
    }

    func configure(with config: WireGuardConfiguration) async throws {
        guard let manager = manager else { return }

        let protocolConfiguration = NETunnelProviderProtocol()
        protocolConfiguration.providerBundleIdentifier = "com.example.VPN.Tunnel"
        protocolConfiguration.serverAddress = config.peers.first?.endpoint ?? ""
        protocolConfiguration.providerConfiguration = [
            "wgConfig": config.asWireGuardConfig
        ]

        manager.protocolConfiguration = protocolConfiguration
        manager.localizedDescription = "My VPN"
        manager.isEnabled = true

        try await manager.saveToPreferences()
    }

    func connect() throws {
        try manager?.connection.startVPNTunnel()
    }

    func disconnect() {
        manager?.connection.stopVPNTunnel()
    }
}
```

---

## パスワード生成

```swift
struct PasswordGenerator {
    enum CharacterSet {
        case lowercase
        case uppercase
        case numbers
        case symbols

        var characters: String {
            switch self {
            case .lowercase: return "abcdefghijklmnopqrstuvwxyz"
            case .uppercase: return "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            case .numbers: return "0123456789"
            case .symbols: return "!@#$%^&*()_+-=[]{}|;:,.<>?"
            }
        }
    }

    func generate(length: Int, using sets: [CharacterSet]) -> String {
        let allCharacters = sets.map(\.characters).joined()
        var password = ""

        for _ in 0..<length {
            if let char = allCharacters.randomElement() {
                password.append(char)
            }
        }

        return password
    }

    func estimateStrength(_ password: String) -> PasswordStrength {
        var score = 0

        if password.count >= 12 { score += 2 }
        else if password.count >= 8 { score += 1 }

        if password.contains(where: { $0.isLowercase }) { score += 1 }
        if password.contains(where: { $0.isUppercase }) { score += 1 }
        if password.contains(where: { $0.isNumber }) { score += 1 }
        if password.contains(where: { "!@#$%^&*".contains($0) }) { score += 1 }

        switch score {
        case 0...2: return .weak
        case 3...4: return .medium
        default: return .strong
        }
    }

    enum PasswordStrength {
        case weak, medium, strong
    }
}
```

---

## Swiftパッケージ機会

### SecureStorageKit

**機能**:
- Keychain抽象化
- 生体認証統合
- 暗号化ヘルパー
- セキュアエンクレーブ

### CryptoHelperKit

**機能**:
- E2E暗号化
- 鍵交換
- 署名検証
- ハッシュ関数

### AuthenticatorKit

**機能**:
- TOTP/HOTP生成
- QRコード読み取り
- バックアップ/復元
- 同期機能

### VPNKit

**機能**:
- WireGuard統合
- OpenVPN対応
- 接続管理
- キルスイッチ

---

## 学習リソース

| アプリ | 学習ポイント |
|--------|-------------|
| SimpleX Chat | E2E暗号化、プライバシー設計 |
| KeePassium | パスワード管理、Keychain |
| Raivo OTP | TOTP実装 |
| WireGuard | VPNトンネル |
| Mullvad VPN | プライバシーVPN |

---

## セキュリティベストプラクティス

### データ保護

| 項目 | 実装 |
|------|------|
| 保存データ | Keychain + 暗号化 |
| 通信 | TLS 1.3 |
| メモリ | センシティブデータの即時消去 |
| ログ | 機密情報除外 |

### 認証

| 項目 | 推奨 |
|------|------|
| 生体認証 | Face ID/Touch ID優先 |
| パスコード | 複雑なパスワード |
| セッション | 適切なタイムアウト |
| 2FA | 必須化検討 |

### コード

| 項目 | 対策 |
|------|------|
| 難読化 | 必要に応じて適用 |
| デバッグ | 本番で無効化 |
| ジェイルブレイク | 検出と対応 |
| 改ざん | 整合性チェック |

---

## トレンド

### 成長中
- ゼロ知識暗号化
- 分散型認証
- パスキー対応

### 安定
- パスワード管理
- 2FA
- VPN

### 注目
- パスキー/FIDO2
- 量子耐性暗号
- 生体認証進化

